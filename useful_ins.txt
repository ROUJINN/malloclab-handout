start with an implicit free list (mm-textbook.c in your handout directory),
then change this to an explicit list
then use the explicit list as the basis for a final version based on segregated lists.

mm-naive.c 很短，一下就可以看完，用来热身
mm-textbook.c 基本上包括各种所需的宏以及存储结构，一定要好好理解清楚
确定了具体保存信息的数据结构之后，一定要先完成 heap checker

最后建议直接在服务器上写这个lab，这样就不会因为机器间的性能差异被坑了！！

64-bit machines, heap size 2^32 bytes
Your allocator must always return pointers that are aligned to 8-byte boundaries
5 各个function功能的介绍
6  Support Routines
8 Programming Rules
11 hints
12 more hints
u只记入uti p只计入thru 

初始试了一下mm-textbook，发现50util,0thru，说明时间很慢

书上：
隐式空闲链表的优点是简单。显著的缺点是任何操作的开销，例如放置分配的块，要求对空闲链表进行搜索，该搜索所需时间与堆中已分配块和空闲块的总数呈线性关系。

我们将看到更加精细复杂的分离式空闲链表组织，它接近于最佳适配策略，不需要进行彻底的堆搜索。

边界标记（boundary tag），允许在常数时间内进行对前面块的合并

在对分配器的讨论中，我们会假设使用立即合并，但是你应该了解，快速的分配器通常会选择某种形式的推迟合并。

使用双向链表（显式空闲链表）而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于我们所选择的空闲链表中块的排序策略。
一种方法是用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。使用 LIFO 的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。
另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比 LIFO 排序的首次适配有更高的内存利用率，接近最佳适配的利用率。
ppt p63对上面的有介绍

简单分离存储：这种简单的方法有许多优点。分配和释放块都是很快的常数时间操作。而且，每个片中都是大小相等的块，不分割，不合并，这意味着每个块只有很少的内存开销。

分离适配是最好的，malloc所用的。

./mdriver -D -V -c ./traces/boat-plus.rep
r -D -V -c -l ./traces/boat.rep
./mdriver -c ./traces/boat-plus.rep
./mdriver ./traces/boat-plus.rep

Results for libc malloc:
  valid  util   ops    secs     Kops  trace
   yes     0%  100000  0.005344 18714 ./traces/alaska.rep
 * yes     0%    4805  0.001538  3125 ./traces/amptjp.rep
 * yes     0%    4162  0.000172 24247 ./traces/bash.rep
 * yes     0%   57716  0.002832 20383 ./traces/boat.rep
 * yes     0%  100000  0.005644 17717 ./traces/boat-plus.rep
 u yes     0%      --        --    -- ./traces/binary2-bal.rep
 * yes     0%    5032  0.000608  8271 ./traces/cccp.rep
 * yes     0%    5848  0.000384 15215 ./traces/cccp-bal.rep
 * yes     0%   11991  0.000437 27427 ./traces/chrome.rep
 * yes     0%   20000  0.000816 24509 ./traces/coalesce-big.rep
   yes     0%   14400  0.000806 17876 ./traces/coalescing-bal.rep
   yes     0%      15  0.000006  2634 ./traces/corners.rep
 * yes     0%    5683  0.001680  3382 ./traces/cp-decl.rep
 u yes     0%      --        --    -- ./traces/exhaust.rep
 * yes     0%    5380  0.000318 16920 ./traces/expr-bal.rep
 * yes     0%   99544  0.004780 20826 ./traces/firefox-reddit2.rep
 * yes     0%   55092  0.002993 18407 ./traces/freeciv.rep
   yes     0%      10  0.000001 16447 ./traces/malloc.rep
   yes     0%      17  0.000001 31628 ./traces/malloc-free.rep
 p yes     --    1494  0.000064 23370 ./traces/perl.rep
 * yes     0%    4800  0.000577  8315 ./traces/random.rep
 * yes     0%    4800  0.000576  8339 ./traces/random2.rep
   yes     0%   14401  0.001069 13473 ./traces/realloc.rep
16 15      0%  386347  0.023419 16497

显式空闲链表+去脚部+立即合并
可以改成延迟合并，暂时先不改吧
感觉malloc时还有个小优化就是就是新加block的size，可以看看前面一个块是不是空的，但是引入这个判断不知道会不会降低效率

最小的free block是8还是16貌似没影响，爽啊，那就不改了

• Use the mdriver -c option or -f option. During initial development, using tiny trace files will
simplify debugging and testing.
• Use the mdriver -V options. The -V option will also indicate when each trace file is processed,
which will help you isolate errors.
• Use the mdriver -D option. This does a lot of checking to quickly find errors.
• Use a debugger. A debugger will help you isolate and identify out-of-bounds memory references.
Modify the Makefile to pass the -g option to gcc and not to pass the -O3 option to gcc when you
are using a debugger. But do not forget to restore the Makefile to the original when doing performance
testing.
• Use gdb’s watch command to find out what changed some value you did not expect to have changed.


trace文件的意思https://111qqz.com/2021/04/csapp-malloclab/
第2个数 多少个不同的内存块
第3个数 操作数，也就是malloc(对应'a'),realloc(对应'r'),free(对应'f')三种操作的个数。

对于每一个操作，如果是malloc/relloc, 后面两个参数分别表示操作几号内存块，以及需要分配的内存大小是多少。如果是free,则只有一个参数，表示要操作几号内存块

gdb mdriver
r -D -V -c ./traces/bash.rep > 1.txt

./mdriver -D -V -c ./traces/short1-bal.rep 只运行一次
./mdriver -D -V -c ./traces/short2.rep
./mdriver -D -V -c ./traces/alaska.rep > 1.txt
./mdriver -D -V -c ./traces/short1-bal.rep > 1.txt
./mdriver

watch *0x800004a1c

x /dw 0x8000004f8
display /dw 0x800004a1c
display /4xb 0x800004a1c

alaska,amptjp,bash,boat,malloc-free

dbg_printf("line:%d,unsigned:%u\n",__LINE__, );
dbg_printf("line:%d,ptr:%p\n",__LINE__, );
dbg_printf("line:%d,ptr:%p,ptr_value:%u\n",__LINE__, );
dbg_printf("line:%d,ptr:%p,ptr_value:%u\n",__LINE__,EXTEND_PTR(tmp_root+WSIZE),GET(tmp_root+WSIZE));

dbg_printf("line:%d,function:%s\n",__LINE__,__FUNCTION__);


貌似用环形链表好一点!!

注意自己改了makefile！！！！测试性能时一定加上O3!!!!
自己注释掉了mdriver里的自动调用checkheap！！！！，来方便printf